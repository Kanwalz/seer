// Code generated by protoc-gen-go. DO NOT EDIT.
// source: seer/seer.proto

/*
Package seer is a generated protocol buffer package.

It is generated from these files:
	seer/seer.proto

It has these top-level messages:
	Stream
	Event
	Interval
	Forecast
	CreateStreamRequest
	GetStreamRequest
	DeleteStreamRequest
	ListStreamsRequest
	ListStreamsResponse
	UpdateStreamRequest
	GetForecastRequest
*/
package seer

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"
import google_protobuf "github.com/golang/protobuf/ptypes/empty"
import google_protobuf1 "github.com/golang/protobuf/ptypes/timestamp"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

type Domain int32

const (
	Domain_CONTINUOUS          Domain = 0
	Domain_CONTINUOUS_RIGHT    Domain = 1
	Domain_CONTINUOUS_INTERVAL Domain = 2
	Domain_DISCRETE_RIGHT      Domain = 3
	Domain_DISCRETE_INTERVAL   Domain = 4
)

var Domain_name = map[int32]string{
	0: "CONTINUOUS",
	1: "CONTINUOUS_RIGHT",
	2: "CONTINUOUS_INTERVAL",
	3: "DISCRETE_RIGHT",
	4: "DISCRETE_INTERVAL",
}
var Domain_value = map[string]int32{
	"CONTINUOUS":          0,
	"CONTINUOUS_RIGHT":    1,
	"CONTINUOUS_INTERVAL": 2,
	"DISCRETE_RIGHT":      3,
	"DISCRETE_INTERVAL":   4,
}

func (x Domain) String() string {
	return proto.EnumName(Domain_name, int32(x))
}
func (Domain) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

// A data stream
type Stream struct {
	Name          string                      `protobuf:"bytes,1,opt,name=name" json:"name,omitempty"`
	Period        float64                     `protobuf:"fixed64,2,opt,name=period" json:"period,omitempty"`
	LastEventTime *google_protobuf1.Timestamp `protobuf:"bytes,3,opt,name=last_event_time,json=lastEventTime" json:"last_event_time,omitempty"`
	Domain        Domain                      `protobuf:"varint,4,opt,name=domain,enum=seer.Domain" json:"domain,omitempty"`
	Min           float64                     `protobuf:"fixed64,5,opt,name=min" json:"min,omitempty"`
	Max           float64                     `protobuf:"fixed64,6,opt,name=max" json:"max,omitempty"`
}

func (m *Stream) Reset()                    { *m = Stream{} }
func (m *Stream) String() string            { return proto.CompactTextString(m) }
func (*Stream) ProtoMessage()               {}
func (*Stream) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

func (m *Stream) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *Stream) GetPeriod() float64 {
	if m != nil {
		return m.Period
	}
	return 0
}

func (m *Stream) GetLastEventTime() *google_protobuf1.Timestamp {
	if m != nil {
		return m.LastEventTime
	}
	return nil
}

func (m *Stream) GetDomain() Domain {
	if m != nil {
		return m.Domain
	}
	return Domain_CONTINUOUS
}

func (m *Stream) GetMin() float64 {
	if m != nil {
		return m.Min
	}
	return 0
}

func (m *Stream) GetMax() float64 {
	if m != nil {
		return m.Max
	}
	return 0
}

// A set of ordered events (values and times) in a stream
type Event struct {
	Times  []*google_protobuf1.Timestamp `protobuf:"bytes,1,rep,name=times" json:"times,omitempty"`
	Values []float64                     `protobuf:"fixed64,2,rep,packed,name=values" json:"values,omitempty"`
}

func (m *Event) Reset()                    { *m = Event{} }
func (m *Event) String() string            { return proto.CompactTextString(m) }
func (*Event) ProtoMessage()               {}
func (*Event) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{1} }

func (m *Event) GetTimes() []*google_protobuf1.Timestamp {
	if m != nil {
		return m.Times
	}
	return nil
}

func (m *Event) GetValues() []float64 {
	if m != nil {
		return m.Values
	}
	return nil
}

// A confidence interval
type Interval struct {
	Probability float64   `protobuf:"fixed64,1,opt,name=probability" json:"probability,omitempty"`
	LowerBound  []float64 `protobuf:"fixed64,2,rep,packed,name=lower_bound,json=lowerBound" json:"lower_bound,omitempty"`
	UpperBound  []float64 `protobuf:"fixed64,3,rep,packed,name=upper_bound,json=upperBound" json:"upper_bound,omitempty"`
}

func (m *Interval) Reset()                    { *m = Interval{} }
func (m *Interval) String() string            { return proto.CompactTextString(m) }
func (*Interval) ProtoMessage()               {}
func (*Interval) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{2} }

func (m *Interval) GetProbability() float64 {
	if m != nil {
		return m.Probability
	}
	return 0
}

func (m *Interval) GetLowerBound() []float64 {
	if m != nil {
		return m.LowerBound
	}
	return nil
}

func (m *Interval) GetUpperBound() []float64 {
	if m != nil {
		return m.UpperBound
	}
	return nil
}

// A forecast, with point predictions and confidence intervals
type Forecast struct {
	Times     []*google_protobuf1.Timestamp `protobuf:"bytes,1,rep,name=times" json:"times,omitempty"`
	Values    []float64                     `protobuf:"fixed64,2,rep,packed,name=values" json:"values,omitempty"`
	Intervals []*Interval                   `protobuf:"bytes,3,rep,name=intervals" json:"intervals,omitempty"`
}

func (m *Forecast) Reset()                    { *m = Forecast{} }
func (m *Forecast) String() string            { return proto.CompactTextString(m) }
func (*Forecast) ProtoMessage()               {}
func (*Forecast) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{3} }

func (m *Forecast) GetTimes() []*google_protobuf1.Timestamp {
	if m != nil {
		return m.Times
	}
	return nil
}

func (m *Forecast) GetValues() []float64 {
	if m != nil {
		return m.Values
	}
	return nil
}

func (m *Forecast) GetIntervals() []*Interval {
	if m != nil {
		return m.Intervals
	}
	return nil
}

// The request message containing the stream to be created
type CreateStreamRequest struct {
	Stream *Stream `protobuf:"bytes,1,opt,name=stream" json:"stream,omitempty"`
}

func (m *CreateStreamRequest) Reset()                    { *m = CreateStreamRequest{} }
func (m *CreateStreamRequest) String() string            { return proto.CompactTextString(m) }
func (*CreateStreamRequest) ProtoMessage()               {}
func (*CreateStreamRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{4} }

func (m *CreateStreamRequest) GetStream() *Stream {
	if m != nil {
		return m.Stream
	}
	return nil
}

// The request message containing the name of the requested stream
type GetStreamRequest struct {
	Name string `protobuf:"bytes,1,opt,name=name" json:"name,omitempty"`
}

func (m *GetStreamRequest) Reset()                    { *m = GetStreamRequest{} }
func (m *GetStreamRequest) String() string            { return proto.CompactTextString(m) }
func (*GetStreamRequest) ProtoMessage()               {}
func (*GetStreamRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{5} }

func (m *GetStreamRequest) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

// The request message containing the name of the stream to be deleted
type DeleteStreamRequest struct {
	Name string `protobuf:"bytes,1,opt,name=name" json:"name,omitempty"`
}

func (m *DeleteStreamRequest) Reset()                    { *m = DeleteStreamRequest{} }
func (m *DeleteStreamRequest) String() string            { return proto.CompactTextString(m) }
func (*DeleteStreamRequest) ProtoMessage()               {}
func (*DeleteStreamRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{6} }

func (m *DeleteStreamRequest) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

// The request message containing the paging data for the stream to list
type ListStreamsRequest struct {
	PageSize   int32 `protobuf:"varint,1,opt,name=page_size,json=pageSize" json:"page_size,omitempty"`
	PageNumber int32 `protobuf:"varint,2,opt,name=page_number,json=pageNumber" json:"page_number,omitempty"`
}

func (m *ListStreamsRequest) Reset()                    { *m = ListStreamsRequest{} }
func (m *ListStreamsRequest) String() string            { return proto.CompactTextString(m) }
func (*ListStreamsRequest) ProtoMessage()               {}
func (*ListStreamsRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{7} }

func (m *ListStreamsRequest) GetPageSize() int32 {
	if m != nil {
		return m.PageSize
	}
	return 0
}

func (m *ListStreamsRequest) GetPageNumber() int32 {
	if m != nil {
		return m.PageNumber
	}
	return 0
}

// The response message containing a list of streams
type ListStreamsResponse struct {
	Streams []*Stream `protobuf:"bytes,1,rep,name=streams" json:"streams,omitempty"`
}

func (m *ListStreamsResponse) Reset()                    { *m = ListStreamsResponse{} }
func (m *ListStreamsResponse) String() string            { return proto.CompactTextString(m) }
func (*ListStreamsResponse) ProtoMessage()               {}
func (*ListStreamsResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{8} }

func (m *ListStreamsResponse) GetStreams() []*Stream {
	if m != nil {
		return m.Streams
	}
	return nil
}

// The request message containing events to apply to the stream
type UpdateStreamRequest struct {
	Event *Event `protobuf:"bytes,1,opt,name=event" json:"event,omitempty"`
}

func (m *UpdateStreamRequest) Reset()                    { *m = UpdateStreamRequest{} }
func (m *UpdateStreamRequest) String() string            { return proto.CompactTextString(m) }
func (*UpdateStreamRequest) ProtoMessage()               {}
func (*UpdateStreamRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{9} }

func (m *UpdateStreamRequest) GetEvent() *Event {
	if m != nil {
		return m.Event
	}
	return nil
}

// The request message containing the forecast length
type GetForecastRequest struct {
	N int32 `protobuf:"varint,1,opt,name=n" json:"n,omitempty"`
}

func (m *GetForecastRequest) Reset()                    { *m = GetForecastRequest{} }
func (m *GetForecastRequest) String() string            { return proto.CompactTextString(m) }
func (*GetForecastRequest) ProtoMessage()               {}
func (*GetForecastRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{10} }

func (m *GetForecastRequest) GetN() int32 {
	if m != nil {
		return m.N
	}
	return 0
}

func init() {
	proto.RegisterType((*Stream)(nil), "seer.Stream")
	proto.RegisterType((*Event)(nil), "seer.Event")
	proto.RegisterType((*Interval)(nil), "seer.Interval")
	proto.RegisterType((*Forecast)(nil), "seer.Forecast")
	proto.RegisterType((*CreateStreamRequest)(nil), "seer.CreateStreamRequest")
	proto.RegisterType((*GetStreamRequest)(nil), "seer.GetStreamRequest")
	proto.RegisterType((*DeleteStreamRequest)(nil), "seer.DeleteStreamRequest")
	proto.RegisterType((*ListStreamsRequest)(nil), "seer.ListStreamsRequest")
	proto.RegisterType((*ListStreamsResponse)(nil), "seer.ListStreamsResponse")
	proto.RegisterType((*UpdateStreamRequest)(nil), "seer.UpdateStreamRequest")
	proto.RegisterType((*GetForecastRequest)(nil), "seer.GetForecastRequest")
	proto.RegisterEnum("seer.Domain", Domain_name, Domain_value)
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// Client API for Seer service

type SeerClient interface {
	// Creates a stream
	CreateStream(ctx context.Context, in *CreateStreamRequest, opts ...grpc.CallOption) (*Stream, error)
	// Gets a stream
	GetStream(ctx context.Context, in *GetStreamRequest, opts ...grpc.CallOption) (*Stream, error)
	// Updates a stream
	UpdateStream(ctx context.Context, in *UpdateStreamRequest, opts ...grpc.CallOption) (*Stream, error)
	// Deletes a stream
	DeleteStream(ctx context.Context, in *DeleteStreamRequest, opts ...grpc.CallOption) (*google_protobuf.Empty, error)
	// Lists streams
	ListStreams(ctx context.Context, in *ListStreamsRequest, opts ...grpc.CallOption) (*ListStreamsResponse, error)
	// Gets a forecast
	GetForecast(ctx context.Context, in *GetForecastRequest, opts ...grpc.CallOption) (*Forecast, error)
}

type seerClient struct {
	cc *grpc.ClientConn
}

func NewSeerClient(cc *grpc.ClientConn) SeerClient {
	return &seerClient{cc}
}

func (c *seerClient) CreateStream(ctx context.Context, in *CreateStreamRequest, opts ...grpc.CallOption) (*Stream, error) {
	out := new(Stream)
	err := grpc.Invoke(ctx, "/seer.Seer/CreateStream", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *seerClient) GetStream(ctx context.Context, in *GetStreamRequest, opts ...grpc.CallOption) (*Stream, error) {
	out := new(Stream)
	err := grpc.Invoke(ctx, "/seer.Seer/GetStream", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *seerClient) UpdateStream(ctx context.Context, in *UpdateStreamRequest, opts ...grpc.CallOption) (*Stream, error) {
	out := new(Stream)
	err := grpc.Invoke(ctx, "/seer.Seer/UpdateStream", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *seerClient) DeleteStream(ctx context.Context, in *DeleteStreamRequest, opts ...grpc.CallOption) (*google_protobuf.Empty, error) {
	out := new(google_protobuf.Empty)
	err := grpc.Invoke(ctx, "/seer.Seer/DeleteStream", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *seerClient) ListStreams(ctx context.Context, in *ListStreamsRequest, opts ...grpc.CallOption) (*ListStreamsResponse, error) {
	out := new(ListStreamsResponse)
	err := grpc.Invoke(ctx, "/seer.Seer/ListStreams", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *seerClient) GetForecast(ctx context.Context, in *GetForecastRequest, opts ...grpc.CallOption) (*Forecast, error) {
	out := new(Forecast)
	err := grpc.Invoke(ctx, "/seer.Seer/GetForecast", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for Seer service

type SeerServer interface {
	// Creates a stream
	CreateStream(context.Context, *CreateStreamRequest) (*Stream, error)
	// Gets a stream
	GetStream(context.Context, *GetStreamRequest) (*Stream, error)
	// Updates a stream
	UpdateStream(context.Context, *UpdateStreamRequest) (*Stream, error)
	// Deletes a stream
	DeleteStream(context.Context, *DeleteStreamRequest) (*google_protobuf.Empty, error)
	// Lists streams
	ListStreams(context.Context, *ListStreamsRequest) (*ListStreamsResponse, error)
	// Gets a forecast
	GetForecast(context.Context, *GetForecastRequest) (*Forecast, error)
}

func RegisterSeerServer(s *grpc.Server, srv SeerServer) {
	s.RegisterService(&_Seer_serviceDesc, srv)
}

func _Seer_CreateStream_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateStreamRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SeerServer).CreateStream(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/seer.Seer/CreateStream",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SeerServer).CreateStream(ctx, req.(*CreateStreamRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Seer_GetStream_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetStreamRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SeerServer).GetStream(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/seer.Seer/GetStream",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SeerServer).GetStream(ctx, req.(*GetStreamRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Seer_UpdateStream_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateStreamRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SeerServer).UpdateStream(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/seer.Seer/UpdateStream",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SeerServer).UpdateStream(ctx, req.(*UpdateStreamRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Seer_DeleteStream_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteStreamRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SeerServer).DeleteStream(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/seer.Seer/DeleteStream",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SeerServer).DeleteStream(ctx, req.(*DeleteStreamRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Seer_ListStreams_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListStreamsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SeerServer).ListStreams(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/seer.Seer/ListStreams",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SeerServer).ListStreams(ctx, req.(*ListStreamsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Seer_GetForecast_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetForecastRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SeerServer).GetForecast(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/seer.Seer/GetForecast",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SeerServer).GetForecast(ctx, req.(*GetForecastRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _Seer_serviceDesc = grpc.ServiceDesc{
	ServiceName: "seer.Seer",
	HandlerType: (*SeerServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "CreateStream",
			Handler:    _Seer_CreateStream_Handler,
		},
		{
			MethodName: "GetStream",
			Handler:    _Seer_GetStream_Handler,
		},
		{
			MethodName: "UpdateStream",
			Handler:    _Seer_UpdateStream_Handler,
		},
		{
			MethodName: "DeleteStream",
			Handler:    _Seer_DeleteStream_Handler,
		},
		{
			MethodName: "ListStreams",
			Handler:    _Seer_ListStreams_Handler,
		},
		{
			MethodName: "GetForecast",
			Handler:    _Seer_GetForecast_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "seer/seer.proto",
}

func init() { proto.RegisterFile("seer/seer.proto", fileDescriptor0) }

var fileDescriptor0 = []byte{
	// 667 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x09, 0x6e, 0x88, 0x02, 0xff, 0xac, 0x54, 0x4d, 0x6f, 0xd3, 0x40,
	0x10, 0x8d, 0xf3, 0x45, 0x33, 0x0e, 0x69, 0x98, 0x40, 0x71, 0xdd, 0x43, 0xcd, 0x0a, 0x55, 0x01,
	0xa1, 0x14, 0xa5, 0x17, 0x2a, 0xc4, 0x81, 0x26, 0xa1, 0x44, 0xaa, 0x52, 0xb1, 0x49, 0xb9, 0x46,
	0x0e, 0x19, 0x2a, 0x4b, 0xfe, 0xc2, 0x76, 0x4a, 0xdb, 0x23, 0x3f, 0x8d, 0x3f, 0xc5, 0x15, 0xed,
	0xae, 0x9d, 0x3a, 0x1f, 0x12, 0x17, 0x2e, 0xd1, 0xee, 0x9b, 0x37, 0x33, 0x7e, 0x33, 0x6f, 0x03,
	0xbb, 0x31, 0x51, 0x74, 0x2c, 0x7e, 0x3a, 0x61, 0x14, 0x24, 0x01, 0x96, 0xc5, 0xd9, 0x3c, 0xb8,
	0x0e, 0x82, 0x6b, 0x97, 0x8e, 0x25, 0x36, 0x5b, 0x7c, 0x3f, 0x26, 0x2f, 0x4c, 0xee, 0x14, 0xc5,
	0x3c, 0x5c, 0x0f, 0x26, 0x8e, 0x47, 0x71, 0x62, 0x7b, 0xa1, 0x22, 0xb0, 0xdf, 0x1a, 0x54, 0xc7,
	0x49, 0x44, 0xb6, 0x87, 0x08, 0x65, 0xdf, 0xf6, 0xc8, 0xd0, 0x2c, 0xad, 0x5d, 0xe3, 0xf2, 0x8c,
	0x7b, 0x50, 0x0d, 0x29, 0x72, 0x82, 0xb9, 0x51, 0xb4, 0xb4, 0xb6, 0xc6, 0xd3, 0x1b, 0x9e, 0xc1,
	0xae, 0x6b, 0xc7, 0xc9, 0x94, 0x6e, 0xc8, 0x4f, 0xa6, 0xa2, 0xa8, 0x51, 0xb2, 0xb4, 0xb6, 0xde,
	0x35, 0x3b, 0xaa, 0x63, 0x27, 0xeb, 0xd8, 0x99, 0x64, 0x1d, 0xf9, 0x63, 0x91, 0x32, 0x10, 0x19,
	0x02, 0xc3, 0x97, 0x50, 0x9d, 0x07, 0x9e, 0xed, 0xf8, 0x46, 0xd9, 0xd2, 0xda, 0x8d, 0x6e, 0xbd,
	0x23, 0xb5, 0xf5, 0x25, 0xc6, 0xd3, 0x18, 0x36, 0xa1, 0xe4, 0x39, 0xbe, 0x51, 0x91, 0xed, 0xc5,
	0x51, 0x22, 0xf6, 0xad, 0x51, 0x4d, 0x11, 0xfb, 0x96, 0x7d, 0x81, 0x8a, 0x2c, 0x8b, 0x6f, 0xa1,
	0x22, 0x05, 0x1a, 0x9a, 0x55, 0xfa, 0xc7, 0xc7, 0x28, 0xa2, 0x10, 0x78, 0x63, 0xbb, 0x0b, 0x8a,
	0x8d, 0xa2, 0x55, 0x12, 0x02, 0xd5, 0x8d, 0xf9, 0xb0, 0x33, 0xf4, 0x13, 0x8a, 0x6e, 0x6c, 0x17,
	0x2d, 0xd0, 0xc3, 0x28, 0x98, 0xd9, 0x33, 0xc7, 0x75, 0x92, 0x3b, 0x39, 0x1f, 0x8d, 0xe7, 0x21,
	0x3c, 0x04, 0xdd, 0x0d, 0x7e, 0x52, 0x34, 0x9d, 0x05, 0x0b, 0x7f, 0x9e, 0x96, 0x02, 0x09, 0x9d,
	0x09, 0x44, 0x10, 0x16, 0x61, 0xb8, 0x24, 0x94, 0x14, 0x41, 0x42, 0x92, 0xc0, 0x7e, 0x69, 0xb0,
	0xf3, 0x29, 0x88, 0xe8, 0x9b, 0x1d, 0xff, 0x47, 0x19, 0xf8, 0x06, 0x6a, 0x4e, 0x2a, 0x23, 0x96,
	0x5d, 0xf5, 0x6e, 0x43, 0x8d, 0x39, 0x53, 0xc7, 0x1f, 0x08, 0xec, 0x3d, 0xb4, 0x7a, 0x11, 0xd9,
	0x09, 0x29, 0x47, 0x70, 0xfa, 0xb1, 0xa0, 0x38, 0x11, 0x8b, 0x8a, 0x25, 0x20, 0xa5, 0xeb, 0xd9,
	0xa2, 0x52, 0x52, 0x1a, 0x63, 0x47, 0xd0, 0x3c, 0xa7, 0x64, 0x35, 0x73, 0x8b, 0xa5, 0xd8, 0x2b,
	0x68, 0xf5, 0xc9, 0xa5, 0xf5, 0x26, 0xdb, 0xa8, 0x1c, 0xf0, 0xc2, 0x89, 0xd3, 0x9a, 0x71, 0xc6,
	0x3c, 0x80, 0x5a, 0x68, 0x5f, 0xd3, 0x34, 0x76, 0xee, 0x15, 0xbd, 0xc2, 0x77, 0x04, 0x30, 0x76,
	0xee, 0x49, 0x0c, 0x5a, 0x06, 0xfd, 0x85, 0x37, 0xa3, 0x48, 0xba, 0xb6, 0xc2, 0x41, 0x40, 0x23,
	0x89, 0xb0, 0x0f, 0xd0, 0x5a, 0xa9, 0x19, 0x87, 0x81, 0x1f, 0x13, 0x1e, 0xc1, 0x23, 0xa5, 0x23,
	0x1b, 0xfa, 0xaa, 0xc8, 0x2c, 0xc8, 0xde, 0x41, 0xeb, 0x2a, 0x9c, 0x6f, 0x8c, 0xe8, 0x05, 0x54,
	0xe4, 0x53, 0x48, 0x27, 0xa4, 0xab, 0x64, 0x69, 0x4a, 0xae, 0x22, 0x8c, 0x01, 0x9e, 0x53, 0x92,
	0xed, 0x38, 0x4b, 0xac, 0x83, 0xe6, 0xa7, 0x22, 0x34, 0xff, 0x75, 0x04, 0x55, 0x65, 0x7f, 0x6c,
	0x00, 0xf4, 0x2e, 0x47, 0x93, 0xe1, 0xe8, 0xea, 0xf2, 0x6a, 0xdc, 0x2c, 0xe0, 0x53, 0x68, 0x3e,
	0xdc, 0xa7, 0x7c, 0x78, 0xfe, 0x79, 0xd2, 0xd4, 0xf0, 0x39, 0xb4, 0x72, 0xe8, 0x70, 0x34, 0x19,
	0xf0, 0xaf, 0x1f, 0x2f, 0x9a, 0x45, 0x44, 0x68, 0xf4, 0x87, 0xe3, 0x1e, 0x1f, 0x4c, 0x06, 0x29,
	0xb9, 0x84, 0xcf, 0xe0, 0xc9, 0x12, 0x5b, 0x52, 0xcb, 0xdd, 0x3f, 0x45, 0x28, 0x8f, 0x89, 0x22,
	0x3c, 0x85, 0x7a, 0x7e, 0xfb, 0xb8, 0xaf, 0x44, 0x6c, 0x71, 0x84, 0xb9, 0x32, 0x1c, 0x56, 0xc0,
	0x13, 0xa8, 0x2d, 0x77, 0x8f, 0x7b, 0x2a, 0xb8, 0x6e, 0x86, 0x8d, 0xa4, 0x53, 0xa8, 0xe7, 0x47,
	0x99, 0xf5, 0xdb, 0x32, 0xde, 0x8d, 0xd4, 0x1e, 0xd4, 0xf3, 0x1e, 0xca, 0x52, 0xb7, 0xf8, 0xca,
	0xdc, 0xdb, 0x78, 0x3c, 0x03, 0xf1, 0xff, 0xc8, 0x0a, 0xd8, 0x07, 0x3d, 0xe7, 0x04, 0x34, 0x54,
	0x8d, 0x4d, 0xc3, 0x99, 0xfb, 0x5b, 0x22, 0xca, 0x36, 0x52, 0x85, 0x9e, 0x5b, 0x6b, 0x56, 0x65,
	0x73, 0xd3, 0x66, 0xfa, 0xee, 0x32, 0x98, 0x15, 0x66, 0x55, 0xf9, 0x49, 0x27, 0x7f, 0x03, 0x00,
	0x00, 0xff, 0xff, 0xa4, 0xa7, 0x01, 0x79, 0xd9, 0x05, 0x00, 0x00,
}
